local acidrain = require('acidrain.acidrain')
local constants = require('main.player.constants')

local TILE = hash("tile")
local TOUCH = hash("touch")
local SECONDARY_TOUCH = hash("secondary_touch")
local PARTICLE_TOUCHED_WALL = hash("particle_touched_wall")
local REACHED = hash("reached")

-- Cone raycast parameters
local CONE_ANGLE = 15      -- Total cone angle in degrees
local NUM_RAYS = 3         -- Number of rays to cast (odd number works well for symmetry)

local REAR_CONE_ANGLE = 40 -- Total rear cone angle in degrees
local REAR_NUM_RAYS = 2    -- Number of rays to cast

local RED = vmath.vector4(1, 0, 0, 1)
local GREEN = vmath.vector4(0, 1, 0, 1)
local BLUE = vmath.vector4(0, 0, 1, 1)
local YELLOW = vmath.vector4(1, 1, 0, 1)
local DEBUG = false

local CAMERA_ID = "cam#camera"

-- Tentacle state constants (must match tentacle.script)
local IDLE = 1
local GOING = 2
local RETURNING = 3
local ATTACHED = 4

local MAX_SPLATS = 100

go.property("speed", 5000)
go.property("far_distance", 1800)

local function draw_line(from, to, color)
	if not DEBUG then
		return
	end
	msg.post("@render:", "draw_line", { start_point = from, end_point = to, color = color })
end


local function cast_cone(from, direction, max_distance, groups, cone_angle, num_rays)
	local results = {}
	local half_angle = math.rad(cone_angle / 2)

	-- Normalize the direction vector
	local dir = vmath.normalize(direction)

	-- Calculate the base angle of the direction
	local base_angle = math.atan2(dir.y, dir.x)

	-- Cast multiple rays in a cone pattern
	for i = 0, num_rays - 1 do
		-- Calculate angle offset from center ray
		local angle_offset = -half_angle + (half_angle * 2 * i / (num_rays - 1))
		local ray_angle = base_angle + angle_offset

		-- Calculate ray direction
		local ray_dir = vmath.vector3(
			math.cos(ray_angle),
			math.sin(ray_angle),
			0
		)

		-- Calculate end point
		local to = from + ray_dir * max_distance

		-- Perform raycast
		local result = physics.raycast(from, to, groups)

		if result then
			table.insert(results, result)

			draw_line(from, result.position, RED)
		else
			draw_line(from, to, BLUE)
		end
	end

	return results
end

local function find_tentacle(self)
	for index, value in ipairs(self.tentacles) do
		local tentacle_state = value.state
		if tentacle_state == IDLE then
			return value
		end
	end
end

local function move_pivots_smoothly(self, hits, tentacle_moved)
	toggle_joint(self, tentacle_moved, true) -- First we activate the pivot if it's not yet.
	if self.animations[tentacle_moved] then -- Verify if animation is done
		self.animations[tentacle_moved] = false
		local player_pos = go.get_position()
		go.set_position(player_pos, self.pivot_ids[tentacle_moved])

		local tentacle_to_remove = self.active_tentacles[tentacle_moved]
		if tentacle_to_remove then
			local original_pivot_index = self.tentacles[tentacle_to_remove.index].pivot_index
			if original_pivot_index then
				self.tentacles[tentacle_to_remove.index].prev_state = self.tentacles[tentacle_to_remove.index].state
				self.tentacles[tentacle_to_remove.index].state = RETURNING
				go.set(self.tentacles[tentacle_to_remove.index].id, "use_speed", true)
				table.remove(self.active_tentacles, tentacle_moved)
				go.set(self.tentacles[tentacle_to_remove.index].id, "target_pos", go.get_position())
			end
		end


		local chosen_tentacle = find_tentacle(self)
		if chosen_tentacle then
			chosen_tentacle.pivot_index = tentacle_moved
			table.insert(self.active_tentacles, tentacle_moved, chosen_tentacle)
			self.tentacles[chosen_tentacle.index].prev_state = self.tentacles[chosen_tentacle.index].state
			self.tentacles[chosen_tentacle.index].state = GOING
		end

		go.set(self.pivot_ids[tentacle_moved] .. "#sprite", "tint.w", 0)
		go.animate(self.pivot_ids[tentacle_moved], "position", go.PLAYBACK_ONCE_FORWARD,
			hits[tentacle_moved].position,
			go.EASING_LINEAR,
			self.tentacle_timeout, 0, function(self, url, property)
				self.animations[tentacle_moved] = true

				-- local chosen_tentacle = find_tentacle(self)
				-- if chosen_tentacle then
				-- 	chosen_tentacle.pivot_index = tentacle_moved
				-- 	table.insert(self.active_tentacles, tentacle_moved, chosen_tentacle)
				-- if chosen_tentacle then
					self.tentacles[chosen_tentacle.index].prev_state = self.tentacles[chosen_tentacle.index].state
					self.tentacles[chosen_tentacle.index].state = ATTACHED
					go.set(self.pivot_ids[tentacle_moved] .. "#sprite", "tint.w", 1)

					self.moved_tentacles = self.moved_tentacles + 1

					if self.moved_tentacles > #self.pivot_ids then
						self.moved_tentacles = 1
					end
				-- end
			end)
	end
end

function init(self)
	msg.post(".", "acquire_input_focus")
	self.gravity = physics.get_gravity()

	self.to = vmath.vector3()

	-- Pivoting
	-- Setting up ids
	self.pivots = {} -- Game Objects (collision objects)
	self.pivot_ids = {} -- Pivot Game Object IDs
	self.tentacles = {} -- Tentacle Scripts
	self.joint_ids = {}
	self.joints_enabled = {}
	self.debug_labels = {}
	self.animations = {}


	for i = 1, 3, 1 do
		local pivot_id = "pivot_" .. tostring(i)
		table.insert(self.pivot_ids, pivot_id)
		table.insert(self.pivots, pivot_id .. "#collisionobject")

		table.insert(self.debug_labels, pivot_id .. "#label")

		table.insert(self.joint_ids, pivot_id .. "_joint")
		table.insert(self.joints_enabled, false)
		table.insert(self.animations, true)

		go.set(pivot_id .. "#sprite", "tint.w", 0)
	end

	for i = 1, 6, 1 do
		local tentacle_id = "tentacle_" .. tostring(i) .. "#tentacle"
		table.insert(self.tentacles, { id = tentacle_id, state = IDLE, prev_state = IDLE, index = i, pivot_index = nil })
		go.set(tentacle_id, "index", i)
	end

	self.active_tentacles = {}

	self.weight_spring = "player#collisionobject"

	self.hits = {}
	self.rear_hits = {}

	self.tentacle_timeout = 0.2
	self.tentacle_timer = 0
	self.can_move_tentacle = true
	self.moved_tentacles = 1

	self.blood_particle_timeout = 1
	self.blood_particle_timer = 0
	self.can_emit_blood = true

	self.blood_emitter = acidrain.create(constants.blood_splat_particle)

	self.splats_created = {}

	self.action_pos = vmath.vector3()
	self.last_screen_pos = nil -- stores the last mouse screen position for per-frame recalculation
end

local function recalculate_to(self)
	if not self.last_screen_pos then
		return
	end
	local mouse_world = camera.screen_to_world(self.last_screen_pos, CAMERA_ID)
	local player_pos = go.get_position()

	local dx = mouse_world.x - player_pos.x
	local dy = mouse_world.y - player_pos.y
	local angle = math.atan2(dy, dx)

	local direction = vmath.vector3(math.cos(angle), math.sin(angle), 0)
	self.to = player_pos + direction * self.far_distance
end

function update(self, dt)
	-- Recalculate self.to every frame so it stays valid as camera/player move
	recalculate_to(self)

	self.blood_emitter.update(dt)

	-- blood particles using AcidRain
	if self.blood_particle_timer > self.blood_particle_timeout and not self.can_emit_blood then
		self.can_emit_blood = true
		self.blood_particle_timer = 0
	else
		self.blood_particle_timer = self.blood_particle_timer + dt
	end

	-- Tentacling
	if self.tentacle_timer > self.tentacle_timeout then
		self.can_move_tentacle = true
	else
		self.tentacle_timer = self.tentacle_timer + dt
	end

	-- Pivoting
	local weight_pos = go.get_position(self.weight_spring)
	for _, value in ipairs(self.pivots) do
		local pivot_pos = go.get_position(value)
		draw_line(pivot_pos, weight_pos, GREEN)
	end

	-- Raycasting
	local from = go.get_position()
	local direction = self.to - from
	local max_distance = vmath.length(direction)

	-- Perform cone raycast + rears
	self.hits = cast_cone(from, direction, max_distance, { TILE }, CONE_ANGLE, NUM_RAYS)
	self.rear_hits = cast_cone(from, direction, max_distance, { TILE }, REAR_CONE_ANGLE, REAR_NUM_RAYS)

	-- Get player position once for all tentacles
	local player_pos = go.get_position()

	-- Update each tentacle based on its state
	for index, tentacle in ipairs(self.tentacles) do
		local tentacle_url = tentacle.id
		local tentacle_state = tentacle.state
		local tentacle_index = tentacle.index
		if tentacle_state == IDLE or tentacle_state == RETURNING then
			go.set(tentacle_url, "target_pos", player_pos)
			go.set(tentacle_url, "owner_pos", player_pos)
		elseif tentacle_state == ATTACHED or tentacle_state == GOING then
			local pivot_pos = go.get_position(self.pivot_ids[tentacle.pivot_index])
			go.set(tentacle_url, "target_pos", pivot_pos)
			go.set(tentacle_url, "owner_pos", player_pos)
		end

		go.set(tentacle_url, "state", tentacle_state)
	end


	-- Debugger set labels
	if DEBUG then
		local text = ""
		for index, value in ipairs(self.tentacles) do
			text = text .. [[|
			]] ..
			value.id ..
			" state: " ..
			value.state .. " prev_state: " .. value.prev_state .. " pivot_index: " .. tostring(value.pivot_index)
		end
		label.set_text("debugger#label", text)

		for index, value in ipairs(self.debug_labels) do
			label.set_text(value,
				tostring(self.joints_enabled[index]) .. "-" .. tostring(index) .. "-" .. tostring(self.animations[index]))
		end
	end
end

function fixed_update(self, dt)
	self.closest_index = 1
	local previous_distance = 0
	for index, value in ipairs(self.pivot_ids) do
		local pivot_pos = go.get_position(value)
		local player_pos = go.get_position()
		local distance = vmath.length(player_pos - pivot_pos)
		--[[
		si el pivote actual es el mas cercano al jugador
		entonces usamos ese valor para closest_index
		]]
		if index == 1 then
			self.closest_index = index
			previous_distance = distance
		elseif distance < previous_distance then
			self.closest_index = index
			previous_distance = distance
		end
		if distance > self.far_distance then
			pprint("Achinga")
			toggle_joint(self, index, false)
			-- Release the tentacle assigned to this pivot
		end
	end



	if self.mouse_pressed then
		local current_pos = go.get_world_position()

		if self.can_emit_blood then
			self.blood_emitter.start()
			self.can_emit_blood = false
		end

		-- Line from player to mouse
		local difference = self.to - current_pos

		-- Avoid weird physics (might delete this)
		difference.z = 0

		-- Avoid zero division errors
		if vmath.length_sqr(difference) > 1 then
			local direction = vmath.normalize(difference)

			local push_strength = self.speed

			local force_vector = direction * push_strength

			msg.post("#collisionobject", "apply_force", { force = force_vector, position = current_pos })
		end

		-- Launch tentacles to pivots based on hits
		-- Each tentacle is assigned to a specific pivot and stays there
		if self.can_move_tentacle then
			if self.hits[self.moved_tentacles] then
				-- Move the pivot to the hit position
				move_pivots_smoothly(self, self.hits, self.moved_tentacles)
			elseif #self.hits < 2 then
				-- Let's use rear hits instead of hits when there are no results in main hits.
				if self.moved_tentacles > 2 then
					self.moved_tentacles = 1
				end
				if self.rear_hits[self.moved_tentacles] then
					move_pivots_smoothly(self, self.rear_hits, self.moved_tentacles)
				end
			end
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == PARTICLE_TOUCHED_WALL then
		self.blood_emitter.remove(message.go_id)
		-- detect the face of the tile touched
		-- Calculate angle from normal (negated x for swapped horizontal)
		local angle_rad = math.atan2(-message.normal.x, message.normal.y)
		local angle_deg = math.deg(angle_rad)

		-- Normalize to 0-360 range
		if angle_deg < 0 then
			angle_deg = angle_deg + 360
		end

		-- Snap to nearest 90 degrees
		local snapped_deg = math.ceil(angle_deg / 90) * 90

		local rotation = vmath.quat_rotation_z(math.rad(snapped_deg))
		local position = message.position
		position.z = 2

		local splat = factory.create("splat#factory", message.position, rotation, nil, 1)
		table.insert(self.splats_created, splat)

		if #self.splats_created > MAX_SPLATS then
			local oldest_splat = self.splats_created[1]
			local oldest_splat_sprite_url = msg.url(nil, oldest_splat, "sprite")

			table.remove(self.splats_created, 1)
			go.animate(oldest_splat_sprite_url, "tint.w", go.PLAYBACK_ONCE_FORWARD, 0, go.EASING_INCIRC, 0.5, 0,
				function(self, url, property)
					go.delete(url)
				end)
		end
	elseif message_id == REACHED then
		local reached_index = message.index

		local actual_state = self.tentacles[reached_index].state
		if actual_state == RETURNING then
			self.tentacles[reached_index].prev_state = actual_state
			self.tentacles[reached_index].state = IDLE
			self.tentacles[reached_index].pivot_index = nil
			go.set(self.tentacles[reached_index].id, "use_speed", false)
		end
	end
end

function on_input(self, action_id, action)
	if not action_id then
		-- Store screen position so we can recalculate self.to every frame
		self.last_screen_pos = vmath.vector3(action.screen_x, action.screen_y, 0)
		recalculate_to(self)
	elseif action_id == TOUCH then
		if action.pressed then
			self.mouse_pressed = true
		elseif action.released then
			self.mouse_pressed = false

			for index, value in ipairs(self.joint_ids) do
				if self.joints_enabled[index] then
					-- I change the frequency of the closest_index based on distance, so the
					-- player won't fall or do movements that would look weird after a player stopped
					-- clicking and thus moving the mouse
					if index == self.closest_index then
						local hinge_props = physics.get_joint_properties(self.weight_spring, value)
						hinge_props.frequency = .1
						physics.set_joint_properties(self.weight_spring, value,
							hinge_props)
					else
						local hinge_props = physics.get_joint_properties(self.weight_spring, value)
						hinge_props.frequency = .6
						physics.set_joint_properties(self.weight_spring, value,
							hinge_props)
					end
				end
			end
		end
	end
end

function toggle_joint(self, idx, enable_joint)
	if not enable_joint then
		if self.joints_enabled[idx] then
			-- Disable joint
			physics.destroy_joint(self.weight_spring, self.joint_ids[idx])

			self.joints_enabled[idx] = false
		end
	else
		if not self.joints_enabled[idx] then
			self.joints_enabled[idx] = true
			local center_anchor = vmath.vector3(0, 0, 0)
			-- Re-enable joint
			physics.create_joint(
				physics.JOINT_TYPE_SPRING,
				self.weight_spring,
				self.joint_ids[idx],
				center_anchor,
				self.pivots[idx],
				center_anchor,
				{ length = 10, frequency = .1, damping = 1 }
			)
		end
	end
end
