local acidrain = require('acidrain.acidrain')
local constants = require('main.player.constants')

local TILE = hash("tile")
local TOUCH = hash("touch")
local SECONDARY_TOUCH = hash("secondary_touch")
local PARTICLE_TOUCHED_WALL = hash("particle_touched_wall")
local REACHED = hash("reached")

-- Cone raycast parameters
local CONE_ANGLE = 15      -- Total cone angle in degrees
local NUM_RAYS = 3         -- Number of rays to cast (odd number works well for symmetry)

local REAR_CONE_ANGLE = 40 -- Total rear cone angle in degrees
local REAR_NUM_RAYS = 2    -- Number of rays to cast

local RED = vmath.vector4(1, 0, 0, 1)
local GREEN = vmath.vector4(0, 1, 0, 1)
local BLUE = vmath.vector4(0, 0, 1, 1)
local YELLOW = vmath.vector4(1, 1, 0, 1)
local DEBUG = false

local CAMERA_ID = "cam#camera"

local MAX_SPLATS = 100

go.property("speed", 5000)
go.property("far_distance", 3000)

local function draw_line(from, to, color)
	if not DEBUG then
		return
	end
	msg.post("@render:", "draw_line", { start_point = from, end_point = to, color = color })
end


local function cast_cone(from, direction, max_distance, groups, cone_angle, num_rays)
	local results = {}
	local half_angle = math.rad(cone_angle / 2)

	-- Normalize the direction vector
	local dir = vmath.normalize(direction)

	-- Calculate the base angle of the direction
	local base_angle = math.atan2(dir.y, dir.x)

	-- Cast multiple rays in a cone pattern
	for i = 0, num_rays - 1 do
		-- Calculate angle offset from center ray
		local angle_offset = -half_angle + (half_angle * 2 * i / (num_rays - 1))
		local ray_angle = base_angle + angle_offset

		-- Calculate ray direction
		local ray_dir = vmath.vector3(
			math.cos(ray_angle),
			math.sin(ray_angle),
			0
		)

		-- Calculate end point
		local to = from + ray_dir * max_distance

		-- Perform raycast
		local result = physics.raycast(from, to, groups)

		if result then
			table.insert(results, result)

			draw_line(from, result.position, RED)
		else
			draw_line(from, to, BLUE)
		end
	end

	return results
end

local function drop_tentacle(self, pivot_index, player_pos)
	for index, value in ipairs(self.active_tentacles) do
		if value.pivot_index == pivot_index then
			value.pivot_index = nil
			value.is_available = false
			go.set(value.id, "active_index", index)
			msg.post(value.id, "set_idle")
			break
		end
	end
end

local function move_pivots_smoothly(self, hits, tentacle_moved)
	toggle_joint(self, tentacle_moved, true) -- First we activate the pivot if it's not yet.
	if self.animations[tentacle_moved] then -- Verify if animation is done
		self.animations[tentacle_moved] = false
		local player_pos = go.get_position()


		-- local id = factory.create(
		-- 	"/tentacles#factory",
		-- 	player_pos,
		-- 	vmath.quat(), -- identity rotation, IK will control it
		-- 	{},
		-- 	1
		-- )
		drop_tentacle(self, tentacle_moved, player_pos)

		-- find tentacle with nil pivot_index
		local id = ""
		local idx = 1
		for index, value in ipairs(self.active_tentacles) do
			if value.pivot_index == nil and value.is_available then
				id = value.id
				idx = index
				break
			end
		end

		go.set(id, "owner_pos", player_pos)

		self.active_tentacles[idx].pivot_index = tentacle_moved

		go.set_position(player_pos, self.pivot_ids[tentacle_moved])

		msg.post(id, "set_target", { position = player_pos })

		go.set(self.pivots[tentacle_moved].sprite, "tint.w", 0)

		go.animate(self.pivot_ids[tentacle_moved], "position", go.PLAYBACK_ONCE_FORWARD,
			hits[tentacle_moved].position,
			go.EASING_LINEAR,
			self.tentacle_timeout, 0, function(self, url, property)
				self.animations[tentacle_moved] = true

				go.animate(self.pivots[tentacle_moved].sprite, "tint.w", go.PLAYBACK_ONCE_FORWARD, 1,
					go.EASING_INOUTEXPO, 0.15)

				self.moved_tentacles = self.moved_tentacles + 1

				if self.moved_tentacles > #self.pivot_ids then
					self.moved_tentacles = 1
				end
			end)
	end
end

local function recalculate_to(self)
	if not self.last_screen_pos then
		return
	end
	self.mouse_world = camera.screen_to_world(self.last_screen_pos, CAMERA_ID)

	local dx = self.mouse_world.x - self.player_pos.x
	local dy = self.mouse_world.y - self.player_pos.y
	local angle = math.atan2(dy, dx)

	local direction = vmath.vector3(math.cos(angle), math.sin(angle), 0)
	self.to = self.player_pos + direction * self.far_distance
end

function init(self)
	msg.post(".", "acquire_input_focus")
	self.gravity = physics.get_gravity()

	self.to = vmath.vector3()

	-- Pivoting
	-- Setting up ids
	self.pivots = {} -- Game Objects (collision objects)
	self.pivot_ids = {} -- Pivot Game Object IDs
	self.joint_ids = {}
	self.joints_enabled = {}
	self.animations = {}
	self.player_pos = go.get_position()


	for i = 1, 3, 1 do
		table.insert(self.joint_ids, "pivot_" .. tostring(i) .. "_joint")

		table.insert(self.joints_enabled, false)
		table.insert(self.animations, true)

		local built_pivot = factory.create("pivot#factory", self.player_pos)

		table.insert(self.pivot_ids, built_pivot)

		local pivot_co = msg.url(nil, built_pivot, "collisionobject")
		local pivot_sp = msg.url(nil, built_pivot, "sprite")

		table.insert(self.pivots, { collision = pivot_co, sprite = pivot_sp })

		go.set(pivot_sp, "tint.w", 0)
	end

	self.active_tentacles = {}
	for i = 1, 9, 1 do
		local id = factory.create(
			"/tentacles#factory",
			self.player_pos,
			vmath.quat(), -- identity rotation, IK will control it
			{},
			1
		)
		local tentacle_id = msg.url(nil, id, "tentacle")

		table.insert(self.active_tentacles,
			{ id = tentacle_id, index = i, pivot_index = nil, is_available = true })
		go.set(tentacle_id, "active_index", i)
	end

	self.hand_id = "/hand#hand"

	go.set(self.hand_id, "owner_pos", self.player_pos)
	go.set(self.hand_id, "target_pos", self.player_pos)

	self.weight_spring = "player#collisionobject"

	self.hits = {}
	self.rear_hits = {}

	self.tentacle_timeout = 0.2
	self.tentacle_timer = 0
	self.can_move_tentacle = true
	self.moved_tentacles = 1

	self.blood_particle_timeout = 1
	self.blood_particle_timer = 0
	self.can_emit_blood = true

	self.blood_emitter = acidrain.create(constants.blood_splat_particle)

	self.splats_created = {}

	self.action_pos = vmath.vector3()
	self.last_screen_pos = nil -- stores the last mouse screen position for per-frame recalculation
	self.mouse_world = vmath.vector3()
end

function update(self, dt)
	-- Recalculate self.to every frame so it stays valid as camera/player move
	recalculate_to(self)

	self.blood_emitter.update(dt)

	-- blood particles using AcidRain
	if self.blood_particle_timer > self.blood_particle_timeout and not self.can_emit_blood then
		self.can_emit_blood = true
		self.blood_particle_timer = 0
	else
		self.blood_particle_timer = self.blood_particle_timer + dt
	end

	-- Tentacling
	if self.tentacle_timer > self.tentacle_timeout then
		self.can_move_tentacle = true
	else
		self.tentacle_timer = self.tentacle_timer + dt
	end

	-- Pivoting
	local weight_pos = go.get_position(self.weight_spring)
	for _, value in ipairs(self.pivots) do
		local pivot_pos = go.get_position(value.collision)
		draw_line(pivot_pos, weight_pos, GREEN)
	end

	-- Raycasting
	local from = go.get_position()
	local direction = self.to - from
	local max_distance = vmath.length(direction)

	-- Perform cone raycast + rears
	self.hits = cast_cone(from, direction, max_distance, { TILE }, CONE_ANGLE, NUM_RAYS)
	self.rear_hits = cast_cone(from, direction, max_distance, { TILE }, REAR_CONE_ANGLE, REAR_NUM_RAYS)

	-- Get player position once for all tentacles
	self.player_pos = go.get_position()

	for index, value in ipairs(self.active_tentacles) do
		local pivot_pos = go.get_position(self.pivot_ids[value.pivot_index])
		if value.pivot_index then
			go.set(value.id, "target_pos", pivot_pos)
			go.set(value.id, "owner_pos", self.player_pos)
		else
			go.set(value.id, "owner_pos", self.player_pos)
		end
	end

	go.set(self.hand_id, "owner_pos", self.player_pos)
	if self.secondary_mouse_pressed then
		go.set(self.hand_id, "target_pos", self.mouse_world)
	else
		go.set(self.hand_id, "target_pos", self.player_pos)
	end
end

function fixed_update(self, dt)
	self.closest_index = 1
	local previous_distance = 0
	for index, value in ipairs(self.pivot_ids) do
		local pivot_pos = go.get_position(value)
		local player_pos = go.get_position()
		local distance = vmath.length(player_pos - pivot_pos)
		--[[
		if actual pivot is the closest to the player
		then we use that value for closest_index
		]]
		if index == 1 then
			self.closest_index = index
			previous_distance = distance
		elseif distance < previous_distance then
			self.closest_index = index
			previous_distance = distance
		end
		if distance > self.far_distance then
			toggle_joint(self, index, false)
			-- Release the tentacle assigned to this pivot
		end
	end



	if self.mouse_pressed then
		local current_pos = go.get_world_position()

		if self.can_emit_blood then
			self.blood_emitter.start()
			self.can_emit_blood = false
		end

		-- Line from player to mouse
		local difference = self.to - current_pos

		-- Avoid weird physics (might delete this)
		difference.z = 0

		-- Avoid zero division errors
		if vmath.length_sqr(difference) > 1 then
			local direction = vmath.normalize(difference)

			local push_strength = self.speed

			local force_vector = direction * push_strength

			msg.post("#collisionobject", "apply_force", { force = force_vector, position = current_pos })
		end

		-- Launch tentacles to pivots based on hits
		-- Each tentacle is assigned to a specific pivot and stays there
		if self.can_move_tentacle then
			if self.hits[self.moved_tentacles] then
				-- Move the pivot to the hit position
				move_pivots_smoothly(self, self.hits, self.moved_tentacles)
			elseif #self.hits < 2 then
				-- Let's use rear hits instead of hits when there are no results in main hits.
				if self.moved_tentacles > 2 then
					self.moved_tentacles = 1
				end
				if self.rear_hits[self.moved_tentacles] then
					move_pivots_smoothly(self, self.rear_hits, self.moved_tentacles)
				end
			end
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == PARTICLE_TOUCHED_WALL then
		self.blood_emitter.remove(message.go_id)
		-- detect the face of the tile touched
		-- Calculate angle from normal (negated x for swapped horizontal)
		local angle_rad = math.atan2(-message.normal.x, message.normal.y)
		local angle_deg = math.deg(angle_rad)

		-- Normalize to 0-360 range
		if angle_deg < 0 then
			angle_deg = angle_deg + 360
		end

		-- Snap to nearest 90 degrees
		local snapped_deg = math.ceil(angle_deg / 90) * 90

		local rotation = vmath.quat_rotation_z(math.rad(snapped_deg))
		local position = message.position
		position.z = 2

		local splat = factory.create("splat#factory", message.position, rotation, nil, 1)
		table.insert(self.splats_created, splat)

		if #self.splats_created > MAX_SPLATS then
			local oldest_splat = self.splats_created[1]
			local oldest_splat_sprite_url = msg.url(nil, oldest_splat, "sprite")

			table.remove(self.splats_created, 1)
			go.animate(oldest_splat_sprite_url, "tint.w", go.PLAYBACK_ONCE_FORWARD, 0, go.EASING_INCIRC, 0.5, 0,
				function(self, url, property)
					go.delete(url)
				end)
		end
	elseif message_id == REACHED then
		-- pprint("Reached index")
	elseif message_id == hash("free_tentacle") then
		self.active_tentacles[message.active_index].is_available = true
	end
end

function on_input(self, action_id, action)
	if not action_id then
		-- Store screen position so we can recalculate self.to every frame
		self.last_screen_pos = vmath.vector3(action.screen_x, action.screen_y, 0)
		recalculate_to(self)
	elseif action_id == SECONDARY_TOUCH then
		if action.pressed then
			self.secondary_mouse_pressed = true
			go.set(self.hand_id, "is_active", true)
			msg.post("hand_touch#touch", "enable")
		elseif action.released then
			go.set(self.hand_id, "is_active", false)
			self.secondary_mouse_pressed = false
			msg.post("hand_touch#touch", "disable")
		end
	elseif action_id == TOUCH then
		if action.pressed then
			self.mouse_pressed = true
		elseif action.released then
			self.mouse_pressed = false

			for index, value in ipairs(self.joint_ids) do
				if self.joints_enabled[index] then
					-- I change the frequency of the closest_index based on distance, so the
					-- player won't fall or do movements that would look weird after a player stopped
					-- clicking and thus moving the mouse
					if index == self.closest_index then
						local hinge_props = physics.get_joint_properties(self.weight_spring, value)
						hinge_props.frequency = .1
						physics.set_joint_properties(self.weight_spring, value,
							hinge_props)
					else
						local hinge_props = physics.get_joint_properties(self.weight_spring, value)
						hinge_props.frequency = .6
						physics.set_joint_properties(self.weight_spring, value,
							hinge_props)
					end
				end
			end
		end
	end
end

function toggle_joint(self, idx, enable_joint)
	if not enable_joint then
		if self.joints_enabled[idx] then
			-- Disable joint
			physics.destroy_joint(self.weight_spring, self.joint_ids[idx])

			self.joints_enabled[idx] = false
		end
	else
		if not self.joints_enabled[idx] then
			self.joints_enabled[idx] = true
			local center_anchor = vmath.vector3(0, 0, 0)
			-- Re-enable joint
			physics.create_joint(
				physics.JOINT_TYPE_SPRING,
				self.weight_spring,
				self.joint_ids[idx],
				center_anchor,
				self.pivots[idx].collision,
				center_anchor,
				{ length = 10, frequency = .1, damping = 1 }
			)
		end
	end
end
