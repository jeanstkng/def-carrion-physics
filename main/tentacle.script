-- tentacle.go script
local fabrik = require("main.fabrik")

local SET_TARGET = hash("set_target")
local RETRACT = hash("retract")

local SEGMENT_COUNT = 50
local SEGMENT_LENGTH = 30
local DAMPING = 0.5           -- lower = more lag/sway (0.05 very sluggish, 0.3 snappy)
local WAVE_AMPLITUDE = 75     -- side-to-side sway strength
local WAVE_FREQUENCY = 2      -- oscillation speed
local WAVE_PHASE_OFFSET = 0.2 -- phase shift per segment (creates the wave travel)

go.property("target_pos", vmath.vector3())
go.property("owner_pos", vmath.vector3())

function init(self)
	self.chain_ids = {}
	self.segments = {}
	self.velocities = {}
	self.lengths = {}
	self.time = 0

	local base = go.get_world_position()

	for i = 1, SEGMENT_COUNT do
		local spawn_pos = vmath.vector3(base.x, base.y - (i * SEGMENT_LENGTH), 0)

		local id = factory.create(
			"#chain_factory",
			spawn_pos,
			vmath.quat(), -- identity rotation, IK will control it
			{},
			1
		)

		table.insert(self.chain_ids, id)
		table.insert(self.segments, spawn_pos)
		table.insert(self.velocities, vmath.vector3(0, 0, 0))
		table.insert(self.lengths, SEGMENT_LENGTH)
	end

	self.target_pos = vmath.vector3(self.segments[SEGMENT_COUNT])
	self.smooth_target = vmath.vector3(self.target_pos)
	self.active_segments = SEGMENT_COUNT
	self.retracting = false
	self.retract_speed = 300
end

function update(self, dt)
	self.time = self.time + dt
	-- local origin = go.get_world_position()
	local origin = self.owner_pos

	if self.retracting then
		-- local origin = go.get_world_position()
		local origin = self.owner_pos

		-- Advance progress at fixed rate regardless of player movement
		local total_time = vmath.length(self.retract_start_pos - origin) / self.retract_speed
		self.retract_progress = self.retract_progress + (dt / total_time)
		self.retract_progress = math.min(self.retract_progress, 1.0)

		-- Target moves from start pos toward current player pos
		self.target_pos = vmath.lerp(self.retract_progress, self.retract_start_pos, origin)

		self.smooth_target = vmath.lerp(DAMPING, self.smooth_target, self.target_pos)
		fabrik.solve(self.segments, origin, self.smooth_target, self.lengths, 8)

		local segments_to_show = math.max(1, math.ceil((1.0 - self.retract_progress) * SEGMENT_COUNT))
		for i = 1, SEGMENT_COUNT do
			local action = i <= segments_to_show and "enable" or "disable"
			msg.post(msg.url(nil, self.chain_ids[i], "sprite"), action, {})
		end

		if self.retract_progress >= 1.0 then
			finish_retract(self)
		end
	else
		self.smooth_target = vmath.lerp(DAMPING, self.smooth_target, self.target_pos)
		fabrik.solve(self.segments, origin, self.smooth_target, self.lengths, 8)
	end

	apply_wave(self, dt)
	update_visuals(self)
end

function start_retract(self)
	self.retracting = true
	self.smooth_target = vmath.vector3(self.segments[SEGMENT_COUNT])
	-- Store the fixed retraction path
	self.retract_start_pos = vmath.vector3(self.target_pos)
	self.retract_progress = 0 -- 0 to 1
end

function apply_wave(self, dt)
	for i = 2, SEGMENT_COUNT do
		-- Perpendicular direction to the segment
		local seg_dir
		if i < SEGMENT_COUNT then
			seg_dir = vmath.normalize(self.segments[i + 1] - self.segments[i - 1])
		else
			seg_dir = vmath.normalize(self.segments[i] - self.segments[i - 1])
		end

		-- Perpendicular = rotate direction 90 degrees
		local perp = vmath.vector3(-seg_dir.y, seg_dir.x, 0)

		-- Wave increases in amplitude toward the tip (index weight)
		local tip_weight = (i / SEGMENT_COUNT) ^ 1.8
		local wave = math.sin(self.time * WAVE_FREQUENCY + i * WAVE_PHASE_OFFSET)

		self.segments[i] = self.segments[i] + perp * (wave * WAVE_AMPLITUDE * tip_weight * 0.016)
	end
end

function finish_retract(self)
	self.retracting = false
	-- Delete all spawned links
	for _, id in ipairs(self.chain_ids) do
		go.delete(id)
	end
	self.chain_ids = {}
	-- Tell parent the tentacle is gone
	-- msg.post("..", "tentacle_retracted")
end

function update_visuals(self)
	for i = 1, SEGMENT_COUNT do
		local id = self.chain_ids[i]
		if id then
			go.set_position(self.segments[i], id)

			-- Rotate sprite to face next segment
			local next_pos = self.segments[i + 1] or self.segments[i]
			local prev_pos = self.segments[i - 1] or self.segments[i]
			local dir = vmath.normalize(next_pos - prev_pos)
			local angle = math.atan2(dir.y, dir.x) - math.pi * 0.5 -- offset if sprite points up
			go.set_rotation(vmath.quat_rotation_z(angle), id)
		end
	end
end

-- Call this to move the tentacle tip toward something
function set_target(self, world_pos)
	self.target_pos = vmath.vector3(world_pos)
end

function on_message(self, message_id, message)
	if message_id == SET_TARGET then
		set_target(self, message.position)
	elseif message_id == RETRACT then
		start_retract(self)
	end
end

function on_input(self, action_id, action)
	if not action_id then
		-- Convert screen to world if needed
		-- if not self.retracting then
		-- 	self.target_pos = vmath.vector3(action.x, action.y, 0)
		-- end
	elseif action_id == hash("touch") and action.pressed then
		print("yyyy")
		-- start_retract(self)
	elseif action_id == hash("secondary_touch") and action.pressed then
		print("oooo")
		-- go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, vmath.vector3(action.x, action.y, 0), go.EASING_LINEAR, 0.5)
	end
end
